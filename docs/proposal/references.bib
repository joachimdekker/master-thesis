@article{sobania_comprehensive_2023,
	title = {A Comprehensive Survey on Program Synthesis With Evolutionary Algorithms},
	volume = {27},
	issn = {1941-0026},
	url = {https://ieeexplore.ieee.org/document/9743417},
	doi = {10.1109/TEVC.2022.3162324},
	abstract = {The automatic generation of computer programs is one of the main applications with practical relevance in the field of evolutionary computation. With program synthesis techniques not only software developers could be supported in their everyday work but even users without any programming knowledge could be empowered to automate repetitive tasks and implement their own new functionality. In recent years, many novel program synthesis approaches based on evolutionary algorithms have been proposed and evaluated on common benchmark problems. Therefore, we identify and discuss in this survey the relevant evolutionary program synthesis approaches in the literature and provide an in-depth analysis of their performance. The most influential approaches we identify are stack-based, grammar-guided, as well as linear genetic programming ({GP}). For the stack-based approaches, we identify 37 in-scope papers, and for the grammar-guided and linear {GP} approaches, we identify 12 and 5 papers, respectively. Furthermore, we find that these approaches perform well on benchmark problems if there is a simple mapping from the given input to the correct output. On problems where this mapping is complex, e.g., if the problem consists of several subproblems or requires iteration/recursion for a correct solution, results tend to be worse. Consequently, for future work, we encourage researchers not only to use a program’s output for assessing the quality of a solution but also the way toward a solution (e.g., correctly solved subproblems).},
	pages = {82--97},
	number = {1},
	journaltitle = {{IEEE} Transactions on Evolutionary Computation},
	author = {Sobania, Dominik and Schweim, Dirk and Rothlauf, Franz},
	urldate = {2025-01-13},
	date = {2023-02},
	note = {Conference Name: {IEEE} Transactions on Evolutionary Computation},
	keywords = {Benchmark testing, Benchmarks, Codes, Evolutionary computation, Natural languages, Programming, Python, Task analysis, evolutionary algorithms, genetic programming ({GP}), program synthesis},
}

@article{rothermel_methodology_2001,
	title = {A methodology for testing spreadsheets},
	volume = {10},
	issn = {1049-331X, 1557-7392},
	url = {https://dl.acm.org/doi/10.1145/366378.366385},
	doi = {10.1145/366378.366385},
	abstract = {Spreadsheet languages, which include commercial spreadsheets and various research systems, have had a substantial impact on end-user computing. Research shows, however, that spreadsheets often contain faults; thus, we would like to provide at least some of the benefits of formal testing methodologies to the creators of spreadsheets. This article presents a testing methodology that adapts data flow adequacy criteria and coverage monitoring to the task of testing spreadsheets. To accommodate the evaluation model used with spreadsheets, and the interactive process by which they are created, our methodology is incremental. To accommodate the users of spreadsheet languages, we provide an interface to our methodology that does not require an understanding of testing theory. We have  implemented our testing methodology in the context of the Forms/3 visual spreadsheet language. We report  on the methodology, its time and space costs, and the mapping from the testing strategy to the user interface. In an empirical study, we found that test suites created according to our methodology detected, on average, 81\% of the faults in a set of faulty spreadsheets, significantly outperforming randomly generated test suites.},
	pages = {110--147},
	number = {1},
	journaltitle = {{ACM} Transactions on Software Engineering and Methodology},
	shortjournal = {{ACM} Trans. Softw. Eng. Methodol.},
	author = {Rothermel, Gregg and Burnett, Margaret and Li, Lixin and Dupuis, Christopher and Sheretov, Andrei},
	urldate = {2025-01-27},
	date = {2001-01},
	langid = {english},
}

@book{sestoft_spreadsheet_2006,
	location = {Copenhagen, Denmark},
	edition = {Version 1.0 of 2006-09-28},
	title = {A spreadsheet core implementation in C\#},
	isbn = {978-87-7949-135-9},
	series = {{IT} University technical report series / {IT} University of Copenhagen},
	pagetotal = {1},
	number = {{TR}-91 (2006)},
	publisher = {{IT} University of Copenhagen},
	author = {Sestoft, Peter},
	date = {2006},
	langid = {english},
}

@inproceedings{lano_agile_2017,
	title = {Agile Model-driven Engineering of Financial Applications.},
	url = {https://nms.kcl.ac.uk/kevin.lano/finmdd/flexmde17f.pdf},
	pages = {388--392},
	booktitle = {{MoDELS} (Satellite Events)},
	author = {Lano, Kevin and Haughton, Howard P. and Tehrani, Sobhan Yassipour and Alfraihi, Hessa},
	urldate = {2025-01-13},
	date = {2017},
}

@software{apache_software_apache_nodate,
	title = {Apache {POI}},
	url = {https://poi.apache.org/components/spreadsheet/eval.html},
	author = {{Apache Software}},
}

@inproceedings{fisher_automated_2002,
	title = {Automated test case generation for spreadsheets},
	url = {https://ieeexplore.ieee.org/document/1007963},
	doi = {10.1145/581356.581359},
	abstract = {Spreadsheet languages, which include commercial spreadsheets and various research systems, have had a substantial impact on end-user computing. Research shows, however, that spreadsheets often contain faults. Thus, in previous work, we presented a methodology that assists spreadsheet users in testing their spreadsheet formulas. Our empirical studies have shown that this methodology can help end-users test spreadsheets more adequately and efficiently; however, the process of generating test cases can still represent a significant impediment. To address this problem, we have been investigating how to automate test case generation for spreadsheets in ways that support incremental testing and provide immediate visual feedback. We have utilized two techniques for generating test cases, one involving random selection and one involving a goal-oriented approach. We describe these techniques, and report results of an experiment examining their relative costs and benefits.},
	eventtitle = {Proceedings of the 24th International Conference on Software Engineering. {ICSE} 2002},
	pages = {141--151},
	booktitle = {Proceedings of the 24th International Conference on Software Engineering. {ICSE} 2002},
	author = {Fisher, M. and Cao, Mingming and Rothermel, G. and Cook, C.R. and Burnett, M.M.},
	urldate = {2025-01-27},
	date = {2002-05},
	keywords = {Automatic testing, Business, Computer aided software engineering, Computer science, Impedance, Output feedback, Permission, Programming profession, Software engineering, Tail},
}

@inproceedings{cunha_automatically_2010,
	title = {Automatically Inferring {ClassSheet} Models from Spreadsheets},
	url = {https://ieeexplore.ieee.org/document/5635202},
	doi = {10.1109/VLHCC.2010.22},
	abstract = {Many errors in spreadsheet formulas can be avoided if spreadsheets are built automatically from higher-level models that can encode and enforce consistency constraints. However, designing such models is time consuming and requires expertise beyond the knowledge to work with spreadsheets. Legacy spreadsheets pose a particular challenge to the approach of controlling spreadsheet evolution through higher-level models, because the need for a model might be overshadowed by two problems: (A) The benefit of creating a spreadsheet is lacking since the legacy spreadsheet already exists, and (B) existing data must be transferred into the new model-generated spreadsheet. To address these problems and to support the model-driven spreadsheet engineering approach, we have developed a tool that can automatically infer {ClassSheet} models from spreadsheets. To this end, we have adapted a method to infer entity/relationship models from relational database to the spreadsheets/{ClassSheets} realm. We have implemented our techniques in the {HaExcel} framework and integrated it with the {ViTSL}/Gencel spreadsheet generator, which allows the automatic generation of refactored spreadsheets from the inferred {ClassSheet} model. The resulting spreadsheet guides further changes and provably safeguards the spreadsheet against a large class of formula errors. The developed tool is a significant contribution to spreadsheet (reverse) engineering, because it fills an important gap and allows a promising design method ({ClassSheets}) to be applied to a huge collection of legacy spreadsheets with minimal effort.},
	eventtitle = {2010 {IEEE} Symposium on Visual Languages and Human-Centric Computing},
	pages = {93--100},
	booktitle = {2010 {IEEE} Symposium on Visual Languages and Human-Centric Computing},
	author = {Cunha, Jacome and Erwig, Martin and Saraiva, Joao},
	urldate = {2025-01-13},
	date = {2010-09},
	note = {{ISSN}: 1943-6106},
	keywords = {Business, {ClassSheets} inference, Context, Data models, Marketing and sales, Object oriented modeling, Programming, Spreadsheets, Unified modeling language},
}

@inproceedings{engels_classsheets_2005,
	location = {New York, {NY}, {USA}},
	title = {{ClassSheets}: automatic generation of spreadsheet applications from object-oriented specifications},
	isbn = {978-1-58113-993-8},
	url = {https://doi.org/10.1145/1101908.1101929},
	doi = {10.1145/1101908.1101929},
	series = {{ASE} '05},
	shorttitle = {{ClassSheets}},
	abstract = {Spreadsheets are widely used in all kinds of business applications. Numerous studies have shown that they contain many errors that sometimes have dramatic impacts. One reason for this situation is the low-level, cell-oriented development process of spreadsheets.We improve this process by introducing and formalizing a higher-level object-oriented model termed {ClassSheet}. While still following the tabular look-and feel of spreadsheets, {ClassSheets} allow the developer to express explicitly business object structures within a spreadsheet, which is achieved by integrating concepts from the {UML} (Unified Modeling Language). A stepwise automatic transformation process generates a spreadsheet application that is consistent with the {ClassSheet} model. Thus, by deploying the formal underpinning of {ClassSheets}, a large variety of errors can be prevented that occur in many existing spreadsheet applications today.The presented {ClassSheet} approach links spreadsheet applications to the object-oriented modeling world and advocates an automatic model-driven development process for spreadsheet applications of high quality.},
	pages = {124--133},
	booktitle = {Proceedings of the 20th {IEEE}/{ACM} International Conference on Automated Software Engineering},
	publisher = {Association for Computing Machinery},
	author = {Engels, Gregor and Erwig, Martin},
	urldate = {2025-01-26},
	date = {2005-11-07},
}

@inproceedings{roy_deeptc-enhancer_2020,
	location = {Virtual Event Australia},
	title = {{DeepTC}-enhancer: improving the readability of automatically generated tests},
	isbn = {978-1-4503-6768-4},
	url = {https://dl.acm.org/doi/10.1145/3324884.3416622},
	doi = {10.1145/3324884.3416622},
	shorttitle = {{DeepTC}-enhancer},
	eventtitle = {{ASE} '20: 35th {IEEE}/{ACM} International Conference on Automated Software Engineering},
	pages = {287--298},
	booktitle = {Proceedings of the 35th {IEEE}/{ACM} International Conference on Automated Software Engineering},
	publisher = {{ACM}},
	author = {Roy, Devjeet and Zhang, Ziyi and Ma, Maggie and Arnaoudova, Venera and Panichella, Annibale and Panichella, Sebastiano and Gonzalez, Danielle and Mirakhorli, Mehdi},
	urldate = {2025-01-25},
	date = {2020-12-21},
	langid = {english},
}

@software{epplus_software_epplus_nodate,
	title = {{EPPlus}},
	url = {https://github.com/EPPlusSoftware/EPPlus/wiki/Formula-Calculation},
	author = {{EPPlus Software}},
}

@software{aspose_espose_nodate,
	title = {Espose Cells},
	url = {https://products.aspose.com/cells/},
	author = {{Aspose}},
}

@article{amalfitano_exact_2016,
	title = {{EXACT}: A tool for comprehending {VBA}-based Excel spreadsheet applications},
	volume = {28},
	rights = {Copyright © 2016 John Wiley \& Sons, Ltd.},
	issn = {2047-7481},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/smr.1787},
	doi = {10.1002/smr.1787},
	shorttitle = {{EXACT}},
	abstract = {Spreadsheet applications are widely adopted by millions of end users from several application domains and provide strategic support to many business, scientific, industrial, and organizational processes. These applications are usually developed by rapid application development processes, exploiting host scripting languages allowing the basic spreadsheets to provide complex functionality, business rules, and user interfaces. Several factors complicate the comprehension of these applications because they are usually developed and maintained by end users without specific software engineering skills, grow over time, are not adequately documented, and do not present explicit separation between data, business logic, and user interface layers. This paper presents a reverse engineering tool intended to support the comprehension of Excel spreadsheet applications developed using the Visual Basic for Application programming language. The tool has been implemented as an add-in that extends the Excel working environment by providing analysis and visualization features. It is able to extract information about the elements composing the analyzed Excel spreadsheet application, the functionality it exposes through its user interface, and the dependencies among its cells. This information is provided by means of interactive views. The validity of the tool has been assessed by a qualitative case study performed with professional end users from an automotive industrial domain. Copyright © 2016 John Wiley \& Sons, Ltd.},
	pages = {483--505},
	number = {6},
	journaltitle = {Journal of Software: Evolution and Process},
	author = {Amalfitano, Domenico and De Simone, Vincenzo and Fasolino, Anna Rita and Tramontana, Porfirio},
	urldate = {2025-01-13},
	date = {2016},
	langid = {english},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/smr.1787},
	keywords = {Excel reverse engineering, analysis of visual basic for applications, industrial case study, spreadsheet comprehension, visualization tool},
}

@article{cambronero_flashfill_2023,
	title = {{FlashFill}++: Scaling Programming by Example by Cutting to the Chase},
	volume = {7},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3571226},
	doi = {10.1145/3571226},
	shorttitle = {{FlashFill}++},
	abstract = {Programming-by-Examples ({PBE}) involves synthesizing an "intended program" from a small set of user-provided input-output examples. A key {PBE} strategy has been to restrict the search to a carefully designed small domain-specific language ({DSL}) with "effectively-invertible" ({EI}) operators at the top and "effectively-enumerable" ({EE}) operators at the bottom. This facilitates an effective combination of top-down synthesis strategy (which backpropagates outputs over various paths in the {DSL} using inverse functions) with a bottom-up synthesis strategy (which propagates inputs over various paths in the {DSL}). We address the problem of scaling synthesis to large {DSLs} with several non-{EI}/{EE} operators. This is motivated by the need to support a richer class of transformations and the need for readable code generation. We propose a novel solution strategy that relies on propagating fewer values and over fewer paths.
            Our first key idea is that of "cut functions" that prune the set of values being propagated by using knowledge of the sub-{DSL} on the other side. Cuts can be designed to preserve completeness of synthesis; however, {DSL} designers may use incomplete cuts to have finer control over the kind of programs synthesized. In either case, cuts make search feasible for non-{EI}/{EE} operators and efficient for deep {DSLs}. Our second key idea is that of "guarded {DSLs}" that allow a precedence on {DSL} operators, which dynamically controls exploration of various paths in the {DSL}. This makes search efficient over grammars with large fanouts without losing recall. It also makes ranking simpler yet more effective in learning an intended program from very few examples. Both cuts and precedence provide a mechanism to the {DSL} designer to restrict search to a reasonable, and possibly incomplete, space of programs.
            Using cuts and {gDSLs}, we have built {FlashFill}++, an industrial-strength {PBE} engine for performing rich string transformations, including datetime and number manipulations. The {FlashFill}++ {gDSL} is designed to enable readable code generation in different target languages including Excel's formula language, {PowerFx}, and Python. We show {FlashFill}++ is more expressive, more performant, and generates better quality code than comparable existing {PBE} systems. {FlashFill}++ is being deployed in several mass-market products ranging from spreadsheet software to notebooks and business intelligence applications, each with millions of users.},
	pages = {952--981},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Cambronero, José and Gulwani, Sumit and Le, Vu and Perelman, Daniel and Radhakrishna, Arjun and Simon, Clint and Tiwari, Ashish},
	urldate = {2025-01-15},
	date = {2023-01-09},
	langid = {english},
}

@inproceedings{cunha_relational_2012,
	location = {Trento Italy},
	title = {From relational {ClassSheets} to {UML}+{OCL}},
	isbn = {978-1-4503-0857-1},
	url = {https://dl.acm.org/doi/10.1145/2245276.2231957},
	doi = {10.1145/2245276.2231957},
	eventtitle = {{SAC} 2012: {ACM} Symposium on Applied Computing},
	pages = {1151--1158},
	booktitle = {Proceedings of the 27th Annual {ACM} Symposium on Applied Computing},
	publisher = {{ACM}},
	author = {Cunha, Jácome and Fernandes, João Paulo and Saraiva, João},
	urldate = {2025-01-13},
	date = {2012-03-26},
	langid = {english},
}

@inproceedings{cunha_spreadsheets_2009,
	location = {New York, {NY}, {USA}},
	title = {From spreadsheets to relational databases and back},
	isbn = {978-1-60558-327-3},
	url = {https://doi.org/10.1145/1480945.1480972},
	doi = {10.1145/1480945.1480972},
	series = {{PEPM} '09},
	abstract = {This paper presents techniques and tools to transform spreadsheets into relational databases and back. A set of data refinement rules is introduced to map a tabular datatype into a relational database schema. Having expressed the transformation of the two data models as data refinements, we obtain for free the functions that migrate the data. We use well-known relational database techniques to optimize and query the data. Because data refinements define bi-directional transformations we can map such database back to an optimized spreadsheet. We have implemented the data refinement rules and we constructed Haskell-based tools to manipulate, optimize and refactor Excel-like spreadsheets.},
	pages = {179--188},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} workshop on Partial evaluation and program manipulation},
	publisher = {Association for Computing Machinery},
	author = {Cunha, Jácome and Saraiva, João and Visser, Joost},
	urldate = {2025-01-13},
	date = {2009-01-19},
}

@thesis{rask_funsheet_2014,
	title = {Funsheet: Integration of Sheet-Defined Functions in Excel using C\#},
	url = {https://www.itu.dk/people/sestoft/funcalc/RaskTimmermann2014.pdf},
	institution = {{IT} University of Copenhagen},
	type = {Master Thesis},
	author = {Rask, Jonas Druedahl and Timmermann, Simon Eikeland},
	urldate = {2025-01-26},
	date = {2014},
}

@inproceedings{jaffe_meaningful_2018,
	location = {New York, {NY}, {USA}},
	title = {Meaningful variable names for decompiled code: a machine translation approach},
	isbn = {978-1-4503-5714-2},
	url = {https://dl.acm.org/doi/10.1145/3196321.3196330},
	doi = {10.1145/3196321.3196330},
	series = {{ICPC} '18},
	shorttitle = {Meaningful variable names for decompiled code},
	abstract = {When code is compiled, information is lost, including some of the structure of the original source code as well as local identifier names. Existing decompilers can reconstruct much of the original source code, but typically use meaningless placeholder variables for identifier names. Using variable names which are more natural in the given context can make the code much easier to interpret, despite the fact that variable names have no effect on the execution of the program. In theory, it is impossible to recover the original identifier names since that information has been lost. However, most code is natural: it is highly repetitive and predictable based on the context. In this paper we propose a technique that assigns variables meaningful names by taking advantage of this naturalness property. We consider decompiler output to be a noisy distortion of the original source code, where the original source code is transformed into the decompiler output. Using this noisy channel model, we apply standard statistical machine translation approaches to choose natural identifiers, combining a translation model trained on a parallel corpus with a language model trained on unmodified C code. We generate a large parallel corpus from 1.2 {TB} of C source code obtained from {GitHub}. Under the most conservative assumptions, our technique is still able to recover the original variable names up to 16.2\% of the time, which represents a lower bound for performance.},
	pages = {20--30},
	booktitle = {Proceedings of the 26th Conference on Program Comprehension},
	publisher = {Association for Computing Machinery},
	author = {Jaffe, Alan and Lacomis, Jeremy and Schwartz, Edward J. and Le Goues, Claire and Vasilescu, Bogdan},
	urldate = {2025-01-25},
	date = {2018-05-28},
}

@article{cunha_model_2016,
	title = {Model inference for spreadsheets},
	volume = {23},
	issn = {1573-7535},
	url = {https://doi.org/10.1007/s10515-014-0167-x},
	doi = {10.1007/s10515-014-0167-x},
	abstract = {Many errors in spreadsheet formulas can be avoided if spreadsheets are built automatically from higher-level models that can encode and enforce consistency constraints in the generated spreadsheets. Employing this strategy for legacy spreadsheets is difficult, because the model has to be reverse engineered from an existing spreadsheet and existing data must be transferred into the new model-generated spreadsheet. We have developed and implemented a technique that automatically infers relational schemas from spreadsheets. This technique uses particularities from the spreadsheet realm to create better schemas. We have evaluated this technique in two ways: first, we have demonstrated its applicability by using it on a set of real-world spreadsheets. Second, we have run an empirical study with users. The study has shown that the results produced by our technique are comparable to the ones developed by experts starting from the same (legacy) spreadsheet data. Although relational schemas are very useful to model data, they do not fit spreadsheets well, as they do not allow expressing layout. Thus, we have also introduced a mapping between relational schemas and {ClassSheets}. A {ClassSheet} controls further changes to the spreadsheet and safeguards it against a large class of formula errors. The developed tool is a contribution to spreadsheet (reverse) engineering, because it fills an important gap and allows a promising design method ({ClassSheets}) to be applied to a huge collection of legacy spreadsheets with minimal effort.},
	pages = {361--392},
	number = {3},
	journaltitle = {Automated Software Engineering},
	shortjournal = {Autom Softw Eng},
	author = {Cunha, Jácome and Erwig, Martin and Mendes, Jorge and Saraiva, João},
	urldate = {2025-01-13},
	date = {2016-09-01},
	langid = {english},
	keywords = {Artificial Intelligence, Automatic model inference, {ClassSheets}, Empirical validation, Relational model, Spreadsheets},
}

@inproceedings{kahn_natural_1987,
	location = {Berlin, Heidelberg},
	title = {Natural semantics},
	isbn = {978-3-540-47419-7},
	doi = {10.1007/BFb0039592},
	abstract = {During the past few years, many researchers have begun to present semantic specifications in a style that has been strongly advocated by Plotkin in [19]. The purpose of this paper is to introduce in an intuitive manner the essential ideas of the method that we call now Natural Semantics, together with its connections to ideas in logic and computing. Natural Semantics is of interest per se and because it is used as a semantics specification formalism for an interactive computer system that we are currently building at {INRIA}.},
	pages = {22--39},
	booktitle = {{STACS} 87},
	publisher = {Springer},
	author = {Kahn, G.},
	editor = {Brandenburg, Franz J. and Vidal-Naquet, Guy and Wirsing, Martin},
	date = {1987},
	langid = {english},
	keywords = {Abstract Syntax, Inference Rule, Natural Deduction, Static Semantic, Syntactic Category},
}

@article{bock_semantics_2020,
	title = {On the semantics for spreadsheets with sheet-defined functions},
	volume = {57},
	issn = {2590-1184},
	url = {https://www.sciencedirect.com/science/article/pii/S2590118420300204},
	doi = {10.1016/j.cola.2020.100960},
	abstract = {We give an operational semantics for the evaluation of spreadsheets, including sheet-defined and built-in numeric functions in the Funcalc spreadsheet platform. The semantics allows for different implementations and we discuss sheet-defined functions implemented using both interpretation and run-time code generation. The semantics specifies the expected result of a computation, also considering non-deterministic functions, independently of an evaluation mechanism. It can be extended to include the cost of formula evaluation for a cost analysis e.g. for use in parallelization of computations. An interesting future direction is to investigate experimentally how close our semantics is to that of major spreadsheet implementations.},
	pages = {100960},
	journaltitle = {Journal of Computer Languages},
	shortjournal = {Journal of Computer Languages},
	author = {Bock, Alexander Asp and Bøgholm, Thomas and Sestoft, Peter and Thomsen, Bent and Thomsen, Lone Leth},
	urldate = {2025-01-26},
	date = {2020-04-01},
	keywords = {Funcalc, Recalculation, Semantics, Sheet-defined function, Spreadsheet},
}

@thesis{poulsen_optimized_nodate,
	title = {Optimized Recalculation for Spreadsheets with the Use of Support Graph},
	institution = {{IT} University of Copenhagen},
	type = {Master Thesis},
	author = {Poulsen, Morten and Serek, Poul Peter},
	langid = {english},
}

@article{bock_parallel_2021,
	title = {Parallel spreadsheet evaluation and dynamic cycle detection},
	volume = {33},
	issn = {1532-0626, 1532-0634},
	url = {https://onlinelibrary.wiley.com/doi/10.1002/cpe.6218},
	doi = {10.1002/cpe.6218},
	abstract = {It was estimated there would be 72 million users using spreadsheets monthly in 2017 some of which build complex ﬁnancial, scientiﬁc and mathematical models. Most of these end-users are not trained {IT} professionals but domain experts. In the age of multicore computing and ever-increasing amounts of data, how can end-users access this powerful, parallel hardware to accelerate spreadsheet computation? Some existing solutions are usually not fully automatic and require a level of interaction from end-users to facilitate parallel execution. Ideally, an end-user tool would transparently exploit the underlying hardware and automatically discover available parallelism in the spreadsheet without any required interaction.},
	pages = {e6218},
	number = {13},
	journaltitle = {Concurrency and Computation: Practice and Experience},
	shortjournal = {Concurrency and Computation},
	author = {Bock, Alexander Asp},
	urldate = {2025-01-24},
	date = {2021-07-10},
	langid = {english},
}

@inproceedings{hsu_program_2024,
	title = {Program Synthesis on Single-Layer Loop Behavior in Pure Functional Programming},
	url = {https://ieeexplore.ieee.org/document/10612128},
	doi = {10.1109/CEC60901.2024.10612128},
	abstract = {Program synthesis ({PS}) is a field devoted to auto-matically generating computer programs from high-level specifications, and genetic programming ({GP}) is one commonly-used way to achieve {PS}. {PushGP}, operating on a stack-based language, is considered as a state-of-the-art program synthesizer among {GPs}, while another research trend foucus on the grammar-based languages due to the readability and the ease of maintenance. In this paper, we propose the repetitive structure genetic programming ({RSGP}), a new grammar-based program synthesizer under the pure functional programming paradigm. {RSGP} defines a recursive function to simulate the single-layer loop behavior and leverages the minimum redundancy maximum relevance ({\textbackslash}{textmRMR}) feature selection with the Pearson correlation coefficient ({PCC}) to select the capable and diverse programs for the next generation. The experiment results show that {RSGP} outperforms {PushGP}, {CBGP}, and {HOTGP} in terms of the number of successful programs on {CountOdds} and {LastIndexofZero} from {PSBl}, Luhn from {PSB}2, and 3 out of 4 designed problems. Additionally, the ablation study indicates that using {\textbackslash}{textmRMR} with {PCC} does encourage proper problem decomposition with the trade-off of diminishing the search ability within a similar neighborhood. {RSGP} utilizes an adaptation mechanism to balance the trade-off to automatically fit the needs of different problems.},
	eventtitle = {2024 {IEEE} Congress on Evolutionary Computation ({CEC})},
	pages = {1--8},
	booktitle = {2024 {IEEE} Congress on Evolutionary Computation ({CEC})},
	author = {Hsu, Tzu-Hao and Chang, Chi-Hsien and Yu, Tian-Li},
	urldate = {2025-01-13},
	date = {2024-06},
	keywords = {Feature extraction, Genetic Programming, Genetic programming, Maintenance, Market research, Program Synthesis, Redundancy, Search problems, Synthesizers},
}

@inproceedings{biermann_rewriting_2018,
	location = {Cham},
	title = {Rewriting High-Level Spreadsheet Structures into Higher-Order Functional Programs},
	isbn = {978-3-319-73305-0},
	doi = {10.1007/978-3-319-73305-0_2},
	abstract = {Spreadsheets are used heavily in industry and academia. Often, spreadsheet models are developed for years and their complexity grows vastly beyond what the paradigm was originally conceived for. Such complexity often comes at the cost of recalculation performance. However, spreadsheet models usually have some high-level structure that can be used to improve performance by performing independent computation in parallel. In this paper, we devise rules for rewriting high-level spreadsheet structure in the form of so-called cell arrays into higher-order functional programs that can be easily parallelized on multicore processors. We implement our rule set for the experimental Funcalc spreadsheet engine which already implements parallelizable higher-order array functions as well as user-defined higher-order functions. Benchmarks show that our rewriting approach improves recalculation performance for spreadsheets that are dominated by cell arrays.},
	pages = {20--35},
	booktitle = {Practical Aspects of Declarative Languages},
	publisher = {Springer International Publishing},
	author = {Biermann, Florian and Dou, Wensheng and Sestoft, Peter},
	editor = {Calimeri, Francesco and Hamlen, Kevin and Leone, Nicola},
	date = {2018},
	langid = {english},
	keywords = {Array Formula, Cell Array, Form C6R, Higher-order Functional Programs, {IN} {TRANSITIONAL} {CELL}},
}

@thesis{iversen_runtime_nodate,
	title = {Runtime code generation to speed up spreadsheet computations},
	institution = {{IT} University of Copenhagen},
	type = {Master Thesis},
	author = {Iversen, Thomas S},
	langid = {english},
}

@article{turk_sdfunc_2022,
	title = {{SDFunc}: Modular spreadsheet design with sheet-defined functions in Microsoft Excel},
	volume = {52},
	rights = {© 2021 John Wiley \& Sons Ltd.},
	issn = {1097-024X},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.3027},
	doi = {10.1002/spe.3027},
	shorttitle = {{SDFunc}},
	abstract = {The goal of the {SDFunc} tool is to enable spreadsheet developers to build their model computations in Microsoft Excel according to the modular design approach, that is, the separation of the functionalities into independent, interchangeable modules with interfaces that provide input and output elements. This concept has been theoretically developed in recent years and is known as sheet-defined functions in the literature. In this article, we are presenting our implementation of the tool and the evaluation steps that we took to make the tool interesting and suitable for the assessment of the modular approach in spreadsheet development by the industry, specifically within organizational and companies' settings where the spreadsheet developers and end-users involved in experiments expect to use a well-established spreadsheet platform. We also demonstrated that sheet-defined functions can be implemented by development tools already present in Microsoft Excel.},
	pages = {415--426},
	number = {2},
	journaltitle = {Software: Practice and Experience},
	author = {Turk, Tomaž},
	urldate = {2025-01-13},
	date = {2022},
	langid = {english},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.3027},
	keywords = {Microsoft Excel, add-in, modular design, sheet-defined function, spreadsheet},
}

@inproceedings{sestoft_sheet-defined_2013,
	location = {Berlin, Heidelberg},
	title = {Sheet-Defined Functions: Implementation and Initial Evaluation},
	isbn = {978-3-642-38706-7},
	doi = {10.1007/978-3-642-38706-7_8},
	shorttitle = {Sheet-Defined Functions},
	abstract = {Spreadsheets are ubiquitous end-user programming tools, but lack even the simplest abstraction mechanism: The ability to encapsulate a computation as a function. This was observed by Peyton-Jones and others [14], who proposed a mechanism to define such functions using only standard spreadsheet cells, formulas and references.},
	pages = {88--103},
	booktitle = {End-User Development},
	publisher = {Springer},
	author = {Sestoft, Peter and Sørensen, Jens Zeilund},
	editor = {Dittrich, Yvonne and Burnett, Margaret and Mørch, Anders and Redmiles, David},
	date = {2013},
	langid = {english},
}

@article{abdali_spreadsheet_1992,
	title = {Spreadsheet computations in computer algebra},
	volume = {26},
	issn = {0163-5824},
	url = {https://dl.acm.org/doi/10.1145/130933.130936},
	doi = {10.1145/130933.130936},
	abstract = {In this paper, we analyze the concept of spreadsheet computing in computer algebra. Numerical spreadsheet programs have a unique, intuitively clear semantics. But when the variables used in a spreadsheet program are allowed to assume symbolic expressions as values, the meaning of spreadsheet computations is not defined that simply. We consider several alternative models for what spreadsheet computations could mean in the symbolic context. We describe the implementation of spreadsheet features, based on one of these models, in the visual computer algebra environment {MathScribe}.},
	pages = {10--18},
	number = {2},
	journaltitle = {{SIGSAM} Bull.},
	author = {Abdali, S. Kamal and Cherry, Guy W. and Soiffer, Neil},
	urldate = {2025-01-13},
	date = {1992-04-01},
}

@incollection{cunha_spreadsheet_2015,
	location = {Cham},
	title = {Spreadsheet Engineering},
	isbn = {978-3-319-15940-9},
	url = {https://doi.org/10.1007/978-3-319-15940-9_6},
	abstract = {These tutorial notes present a methodology for spreadsheet engineering. First, we present data mining and database techniques to reason about spreadsheet data. These techniques are used to compute relationships between spreadsheet elements (cells/columns/rows), which are later used to infer a model defining the business logic of the spreadsheet. Such a model of a spreadsheet data is a visual domain specific language that we embed in a well-known spreadsheet system.},
	pages = {246--299},
	booktitle = {Central European Functional Programming School: 5th Summer School, {CEFP} 2013, Cluj-Napoca, Romania, July 8-20, 2013, Revised Selected Papers},
	publisher = {Springer International Publishing},
	author = {Cunha, Jácome and Fernandes, João Paulo and Mendes, Jorge and Saraiva, João},
	editor = {Zsók, Viktória and Horváth, Zoltán and Csató, Lehel},
	urldate = {2025-01-13},
	date = {2015},
	langid = {english},
	doi = {10.1007/978-3-319-15940-9_6},
	keywords = {Business Logic, Cell Class, Domain Specific Language, Functional Dependency, Unify Modeling Language},
}

@report{sestoft_spreadsheet_2012,
	title = {Spreadsheet technology},
	institution = {{IT}-Universitetet i København},
	type = {Report},
	author = {Sestoft, Peter},
	date = {2012-01-31},
	note = {Publication Title: Spreadsheet technology
Volume: 2011-142},
}

@software{syncfusion_syncfusion_nodate,
	title = {Syncfusion .{NET} Excel Library},
	url = {https://www.syncfusion.com/document-processing/excel-framework/net/excel-library/formula},
	author = {{Syncfusion}},
}

@inproceedings{ii_test_2002,
	title = {Test reuse in the spreadsheet paradigm},
	url = {https://ieeexplore.ieee.org/abstract/document/1173265?casa_token=F0g9q2DOVv8AAAAA:ZZR8HhYjyVgyfd9JJT2v20cFms4p2ZA0DsO86Vs0DV0v_Y3bCRZUY_5SCBGtrcOb_fo70qLbJpo},
	doi = {10.1109/ISSRE.2002.1173265},
	abstract = {Spreadsheet languages are widely used by a variety of end users to perform many important tasks. Despite their perceived simplicity, spreadsheets often contain faults. Furthermore, users modify their spreadsheets frequently, which can render previously correct spreadsheets faulty. To address this problem, we previously introduced a visual approach by which users can systematically test their spreadsheets, see where new tests are required after changes, and request automated generation of potentially useful test inputs. To date, however, this approach has not taken advantage of previously developed test cases, which means that users of the approach cannot benefit, when re-testing following changes, from prior testing efforts. We have therefore been investigating ways to add support for test re-use into our spreadsheet testing methodology. In this paper we present a test re-use strategy for spreadsheets, and the algorithms that implement it, and describe their integration into our spreadsheet testing methodology. We report results of a case study examining the application of this strategy.},
	eventtitle = {13th International Symposium on Software Reliability Engineering, 2002. Proceedings.},
	pages = {257--268},
	booktitle = {13th International Symposium on Software Reliability Engineering, 2002. Proceedings.},
	author = {Ii, M.F. and Jin, D. and Rothermel, G. and Burnett, M.},
	urldate = {2025-01-27},
	date = {2002-11},
	note = {{ISSN}: 1071-9458},
	keywords = {Automatic testing, Computer science, Financial management, Pharmaceuticals, Quality assessment, Quality management, Safety, Software testing, System testing, Visualization},
}

@inproceedings{cunha_towards_2012,
	location = {Berlin, Heidelberg},
	title = {Towards a Catalog of Spreadsheet Smells},
	isbn = {978-3-642-31128-4},
	doi = {10.1007/978-3-642-31128-4_15},
	abstract = {Spreadsheets are considered to be the most widely used programming language in the world, and reports have shown that 90\% of real-world spreadsheets contain errors.},
	pages = {202--216},
	booktitle = {Computational Science and Its Applications – {ICCSA} 2012},
	publisher = {Springer},
	author = {Cunha, Jácome and Fernandes, João P. and Ribeiro, Hugo and Saraiva, João},
	editor = {Murgante, Beniamino and Gervasi, Osvaldo and Misra, Sanjay and Nedjah, Nadia and Rocha, Ana Maria A. C. and Taniar, David and Apduhan, Bernady O.},
	date = {2012},
	langid = {english},
	keywords = {Code Smells, {EUSES} Corpus, Spreadsheets},
}
